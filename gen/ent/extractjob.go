// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/joseph-ayodele/receipts-tracker/gen/ent/extractjob"
	"github.com/joseph-ayodele/receipts-tracker/gen/ent/profile"
	"github.com/joseph-ayodele/receipts-tracker/gen/ent/receipt"
	"github.com/joseph-ayodele/receipts-tracker/gen/ent/receiptfile"
)

// ExtractJob is the model entity for the ExtractJob schema.
type ExtractJob struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// FileID holds the value of the "file_id" field.
	FileID uuid.UUID `json:"file_id,omitempty"`
	// ProfileID holds the value of the "profile_id" field.
	ProfileID uuid.UUID `json:"profile_id,omitempty"`
	// ReceiptID holds the value of the "receipt_id" field.
	ReceiptID *uuid.UUID `json:"receipt_id,omitempty"`
	// Format holds the value of the "format" field.
	Format string `json:"format,omitempty"`
	// StartedAt holds the value of the "started_at" field.
	StartedAt time.Time `json:"started_at,omitempty"`
	// FinishedAt holds the value of the "finished_at" field.
	FinishedAt *time.Time `json:"finished_at,omitempty"`
	// Status holds the value of the "status" field.
	Status *string `json:"status,omitempty"`
	// ErrorMessage holds the value of the "error_message" field.
	ErrorMessage *string `json:"error_message,omitempty"`
	// ExtractionConfidence holds the value of the "extraction_confidence" field.
	ExtractionConfidence *float32 `json:"extraction_confidence,omitempty"`
	// NeedsReview holds the value of the "needs_review" field.
	NeedsReview bool `json:"needs_review,omitempty"`
	// OcrText holds the value of the "ocr_text" field.
	OcrText *string `json:"ocr_text,omitempty"`
	// ExtractedJSON holds the value of the "extracted_json" field.
	ExtractedJSON json.RawMessage `json:"extracted_json,omitempty"`
	// ModelName holds the value of the "model_name" field.
	ModelName *string `json:"model_name,omitempty"`
	// ModelParams holds the value of the "model_params" field.
	ModelParams json.RawMessage `json:"model_params,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ExtractJobQuery when eager-loading is set.
	Edges        ExtractJobEdges `json:"edges"`
	selectValues sql.SelectValues
}

// ExtractJobEdges holds the relations/edges for other nodes in the graph.
type ExtractJobEdges struct {
	// File holds the value of the file edge.
	File *ReceiptFile `json:"file,omitempty"`
	// Profile holds the value of the profile edge.
	Profile *Profile `json:"profile,omitempty"`
	// Receipt holds the value of the receipt edge.
	Receipt *Receipt `json:"receipt,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// FileOrErr returns the File value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ExtractJobEdges) FileOrErr() (*ReceiptFile, error) {
	if e.File != nil {
		return e.File, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: receiptfile.Label}
	}
	return nil, &NotLoadedError{edge: "file"}
}

// ProfileOrErr returns the Profile value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ExtractJobEdges) ProfileOrErr() (*Profile, error) {
	if e.Profile != nil {
		return e.Profile, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: profile.Label}
	}
	return nil, &NotLoadedError{edge: "profile"}
}

// ReceiptOrErr returns the Receipt value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ExtractJobEdges) ReceiptOrErr() (*Receipt, error) {
	if e.Receipt != nil {
		return e.Receipt, nil
	} else if e.loadedTypes[2] {
		return nil, &NotFoundError{label: receipt.Label}
	}
	return nil, &NotLoadedError{edge: "receipt"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ExtractJob) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case extractjob.FieldReceiptID:
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		case extractjob.FieldExtractedJSON, extractjob.FieldModelParams:
			values[i] = new([]byte)
		case extractjob.FieldNeedsReview:
			values[i] = new(sql.NullBool)
		case extractjob.FieldExtractionConfidence:
			values[i] = new(sql.NullFloat64)
		case extractjob.FieldFormat, extractjob.FieldStatus, extractjob.FieldErrorMessage, extractjob.FieldOcrText, extractjob.FieldModelName:
			values[i] = new(sql.NullString)
		case extractjob.FieldStartedAt, extractjob.FieldFinishedAt:
			values[i] = new(sql.NullTime)
		case extractjob.FieldID, extractjob.FieldFileID, extractjob.FieldProfileID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ExtractJob fields.
func (_m *ExtractJob) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case extractjob.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				_m.ID = *value
			}
		case extractjob.FieldFileID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field file_id", values[i])
			} else if value != nil {
				_m.FileID = *value
			}
		case extractjob.FieldProfileID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field profile_id", values[i])
			} else if value != nil {
				_m.ProfileID = *value
			}
		case extractjob.FieldReceiptID:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field receipt_id", values[i])
			} else if value.Valid {
				_m.ReceiptID = new(uuid.UUID)
				*_m.ReceiptID = *value.S.(*uuid.UUID)
			}
		case extractjob.FieldFormat:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field format", values[i])
			} else if value.Valid {
				_m.Format = value.String
			}
		case extractjob.FieldStartedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field started_at", values[i])
			} else if value.Valid {
				_m.StartedAt = value.Time
			}
		case extractjob.FieldFinishedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field finished_at", values[i])
			} else if value.Valid {
				_m.FinishedAt = new(time.Time)
				*_m.FinishedAt = value.Time
			}
		case extractjob.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				_m.Status = new(string)
				*_m.Status = value.String
			}
		case extractjob.FieldErrorMessage:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field error_message", values[i])
			} else if value.Valid {
				_m.ErrorMessage = new(string)
				*_m.ErrorMessage = value.String
			}
		case extractjob.FieldExtractionConfidence:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field extraction_confidence", values[i])
			} else if value.Valid {
				_m.ExtractionConfidence = new(float32)
				*_m.ExtractionConfidence = float32(value.Float64)
			}
		case extractjob.FieldNeedsReview:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field needs_review", values[i])
			} else if value.Valid {
				_m.NeedsReview = value.Bool
			}
		case extractjob.FieldOcrText:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ocr_text", values[i])
			} else if value.Valid {
				_m.OcrText = new(string)
				*_m.OcrText = value.String
			}
		case extractjob.FieldExtractedJSON:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field extracted_json", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.ExtractedJSON); err != nil {
					return fmt.Errorf("unmarshal field extracted_json: %w", err)
				}
			}
		case extractjob.FieldModelName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field model_name", values[i])
			} else if value.Valid {
				_m.ModelName = new(string)
				*_m.ModelName = value.String
			}
		case extractjob.FieldModelParams:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field model_params", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.ModelParams); err != nil {
					return fmt.Errorf("unmarshal field model_params: %w", err)
				}
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the ExtractJob.
// This includes values selected through modifiers, order, etc.
func (_m *ExtractJob) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryFile queries the "file" edge of the ExtractJob entity.
func (_m *ExtractJob) QueryFile() *ReceiptFileQuery {
	return NewExtractJobClient(_m.config).QueryFile(_m)
}

// QueryProfile queries the "profile" edge of the ExtractJob entity.
func (_m *ExtractJob) QueryProfile() *ProfileQuery {
	return NewExtractJobClient(_m.config).QueryProfile(_m)
}

// QueryReceipt queries the "receipt" edge of the ExtractJob entity.
func (_m *ExtractJob) QueryReceipt() *ReceiptQuery {
	return NewExtractJobClient(_m.config).QueryReceipt(_m)
}

// Update returns a builder for updating this ExtractJob.
// Note that you need to call ExtractJob.Unwrap() before calling this method if this ExtractJob
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *ExtractJob) Update() *ExtractJobUpdateOne {
	return NewExtractJobClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the ExtractJob entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *ExtractJob) Unwrap() *ExtractJob {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: ExtractJob is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *ExtractJob) String() string {
	var builder strings.Builder
	builder.WriteString("ExtractJob(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("file_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.FileID))
	builder.WriteString(", ")
	builder.WriteString("profile_id=")
	builder.WriteString(fmt.Sprintf("%v", _m.ProfileID))
	builder.WriteString(", ")
	if v := _m.ReceiptID; v != nil {
		builder.WriteString("receipt_id=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("format=")
	builder.WriteString(_m.Format)
	builder.WriteString(", ")
	builder.WriteString("started_at=")
	builder.WriteString(_m.StartedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := _m.FinishedAt; v != nil {
		builder.WriteString("finished_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.Status; v != nil {
		builder.WriteString("status=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.ErrorMessage; v != nil {
		builder.WriteString("error_message=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.ExtractionConfidence; v != nil {
		builder.WriteString("extraction_confidence=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("needs_review=")
	builder.WriteString(fmt.Sprintf("%v", _m.NeedsReview))
	builder.WriteString(", ")
	if v := _m.OcrText; v != nil {
		builder.WriteString("ocr_text=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("extracted_json=")
	builder.WriteString(fmt.Sprintf("%v", _m.ExtractedJSON))
	builder.WriteString(", ")
	if v := _m.ModelName; v != nil {
		builder.WriteString("model_name=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("model_params=")
	builder.WriteString(fmt.Sprintf("%v", _m.ModelParams))
	builder.WriteByte(')')
	return builder.String()
}

// ExtractJobs is a parsable slice of ExtractJob.
type ExtractJobs []*ExtractJob
